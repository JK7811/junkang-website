<!doctype html>
<html lang="zh-Hans">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
  <title>Neon DDT Arena</title>
  <style>
    html,body{height:100%;margin:0}
    body{background:#050507;overflow:hidden;font-family:-apple-system,BlinkMacSystemFont,"Segoe UI",Arial,sans-serif}
    canvas{position:fixed;inset:0;width:100%;height:100%}
    #ui{position:fixed;inset:0;pointer-events:none}
    .topbar{
      position:fixed;left:12px;right:12px;top:12px;
      display:flex;justify-content:space-between;align-items:center;
      padding:10px 12px;border-radius:16px;
      border:1px solid rgba(255,255,255,.12);
      background:rgba(0,0,0,.38);
      backdrop-filter: blur(10px);
      box-shadow:0 20px 70px rgba(0,0,0,.55);
      pointer-events:auto;
    }
    .brand{display:flex;align-items:center;gap:10px;color:rgba(255,255,255,.9);font-weight:900;letter-spacing:.14em;text-transform:uppercase;font-size:12px}
    .dot{width:10px;height:10px;border-radius:50%;background:radial-gradient(circle,rgba(255,215,130,1),rgba(255,215,130,.12));box-shadow:0 0 18px rgba(255,215,130,.35)}
    .right{display:flex;gap:10px;align-items:center}
    .pill{
      color:rgba(255,255,255,.88);font-size:12px;
      padding:8px 10px;border-radius:999px;
      border:1px solid rgba(255,255,255,.12);
      background:rgba(255,255,255,.05);
      pointer-events:auto;
    }
    .btn{
      pointer-events:auto;
      border:1px solid rgba(255,255,255,.12);
      background:rgba(255,255,255,.06);
      color:rgba(255,255,255,.92);
      padding:10px 12px;border-radius:14px;
      font-weight:900;cursor:pointer;
      transition:.15s;
    }
    .btn:hover{transform:translateY(-1px);background:rgba(255,255,255,.10)}
    .btn.primary{background:rgba(255,255,255,.92);color:#000;border-color:transparent}
    .btn.primary:hover{background:#fff}

    /* Aim overlay (minimal text) */
    .hint{
      position:fixed;left:50%;bottom:16px;transform:translateX(-50%);
      color:rgba(255,255,255,.85);font-size:12px;letter-spacing:.06em;
      padding:10px 12px;border-radius:999px;
      border:1px solid rgba(255,255,255,.12);
      background:rgba(0,0,0,.35);
      backdrop-filter: blur(10px);
      pointer-events:none;
      opacity:.9;
    }

    /* Login overlay */
    .overlay{
      position:fixed;inset:0;display:flex;align-items:center;justify-content:center;
      background:radial-gradient(700px 500px at 50% 45%, rgba(255,215,130,.20), rgba(180,120,255,.12), rgba(0,0,0,.92) 70%);
      backdrop-filter: blur(10px);
      z-index:50;
    }
    .loginBox{
      width:min(92vw,560px);
      border-radius:28px;
      border:1px solid rgba(255,255,255,.14);
      background:rgba(255,255,255,.06);
      box-shadow:0 26px 90px rgba(0,0,0,.65);
      padding:16px;position:relative;overflow:hidden;
    }
    .loginBox::before{
      content:"";position:absolute;inset:-2px;
      background:conic-gradient(from 120deg, rgba(255,215,130,.0), rgba(255,215,130,.20), rgba(180,120,255,.18), rgba(120,200,255,.16), rgba(255,215,130,.0));
      filter:blur(10px);opacity:.65;animation:spin 6s linear infinite;
      pointer-events:none;
    }
    @keyframes spin{to{transform:rotate(360deg)}}
    .scanline{
      position:absolute;left:-20%;right:-20%;height:3px;top:0;
      background:linear-gradient(90deg, transparent, rgba(255,215,130,.85), rgba(120,200,255,.75), transparent);
      filter:blur(1px);animation:scan 2.1s ease-in-out infinite;opacity:.85;pointer-events:none;
    }
    @keyframes scan{
      0%{transform:translateY(0);opacity:.2}
      45%{opacity:1}
      100%{transform:translateY(520px);opacity:.2}
    }
    .loginInner{position:relative}
    .title{margin:0;color:#fff;font-weight:1000;letter-spacing:.08em;font-size:28px}
    .sub{margin-top:8px;color:rgba(255,255,255,.75);font-size:12px;line-height:1.7}
    input{
      width:100%;margin-top:12px;
      padding:12px 12px;border-radius:14px;
      border:1px solid rgba(255,255,255,.14);
      background:rgba(0,0,0,.28);color:#fff;outline:none;font-size:14px;
    }
    .row{display:flex;gap:10px;flex-wrap:wrap;margin-top:12px}
    .msg{margin-top:8px;color:rgba(255,255,255,.7);font-size:12px;min-height:18px}
    .hide{display:none}
  </style>
</head>
<body>
  <canvas id="c"></canvas>

  <!-- minimal UI -->
  <div id="ui" class="hide">
    <div class="topbar">
      <div class="brand"><span class="dot"></span>NEON DDT ARENA</div>
      <div class="right">
        <div class="pill" id="acct">Guest</div>
        <div class="pill">Coins: <b id="coins">0</b></div>
        <button class="btn" id="refreshBtn">Refresh</button>
        <button class="btn primary" id="topupBtn">Recharge</button>
        <button class="btn" id="logoutBtn">Logout</button>
      </div>
    </div>
    <div class="hint" id="hint">拖动屏幕瞄准 · 松手发射 · 爆炸/震屏/粒子</div>
  </div>

  <!-- login overlay -->
  <div class="overlay" id="login">
    <div class="loginBox">
      <div class="scanline"></div>
      <div class="loginInner">
        <h1 class="title">LOGIN → ENTER GAME</h1>
        <div class="sub">输入邮箱发送 OTP 登录。登录后直接进入弹弹堂风格对战画面，并可充值 Coins。</div>
        <input id="email" placeholder="you@example.com" />
        <div class="row">
          <button class="btn primary" id="otpBtn">Send OTP</button>
          <button class="btn" id="demoBtn">Demo (No Login)</button>
        </div>
        <div class="msg" id="loginMsg"></div>
      </div>
    </div>
  </div>

  <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>
  <script>
    // ✅ 改这两行
    const SUPABASE_URL = https://yvjnxqhwdcdvtxiygnpn.supabase.co;
    const SUPABASE_ANON_KEY = sb_publishable_6P96zfQTL9QAmChrKKnXaQ_ThyNB2ha;
    const supabase = window.supabase.createClient(SUPABASE_URL, SUPABASE_ANON_KEY);

    const $ = (id)=>document.getElementById(id);

    // ====== AUTH + WALLET ======
    let walletCoins = 0;
    let loggedIn = false;

    async function syncUserUI(){
      const { data } = await supabase.auth.getUser();
      const u = data?.user;
      loggedIn = !!u;
      $("acct").textContent = u ? (u.email || "Player") : "Guest";
    }

    async function refreshWallet(){
      const { data: userData } = await supabase.auth.getUser();
      const user = userData?.user;
      if(!user){ walletCoins = 0; $("coins").textContent = "0"; return; }
      const { data: w } = await supabase.from("wallets").select("coins").eq("user_id", user.id).maybeSingle();
      walletCoins = Number(w?.coins || 0);
      $("coins").textContent = walletCoins.toLocaleString();
    }

    async function sendOtp(){
      const email = $("email").value.trim();
      if(!email){ $("loginMsg").textContent="请输入邮箱"; return; }
      const { error } = await supabase.auth.signInWithOtp({ email });
      if(error){ $("loginMsg").textContent="错误："+error.message; return; }
      $("loginMsg").textContent="已发送 OTP 登录链接到邮箱。打开邮箱点击即可进入游戏。";
    }

    async function logout(){
      await supabase.auth.signOut();
      walletCoins = 0;
      $("coins").textContent="0";
      location.reload();
    }

    async function topup(){
      const { data: s } = await supabase.auth.getSession();
      const token = s?.session?.access_token;
      if(!token){ $("login").classList.remove("hide"); return; }
      // 默认买 300 coins（你也可以做选择包）
      const resp = await fetch("/api/create-checkout-session",{
        method:"POST",
        headers:{ "Content-Type":"application/json","Authorization":"Bearer "+token },
        body: JSON.stringify({ pack: "topup_300" })
      });
      const j = await resp.json();
      if(!resp.ok){ alert(j?.error || "topup failed"); return; }
      location.href = j.url;
    }

    $("otpBtn").onclick = sendOtp;
    $("demoBtn").onclick = () => startGame(false);
    $("logoutBtn").onclick = logout;
    $("topupBtn").onclick = topup;
    $("refreshBtn").onclick = async ()=>{ await refreshWallet(); };

    supabase.auth.onAuthStateChange(async (_evt, _sess)=>{
      // 登录成功后直接进入游戏
      const { data } = await supabase.auth.getUser();
      if(data?.user) startGame(true);
    });

    // ====== GAME (DDT STYLE) ======
    const canvas = $("c");
    const ctx = canvas.getContext("2d");
    let W=0,H=0,DPR=1;

    function resize(){
      DPR = Math.max(1, Math.min(2, devicePixelRatio||1));
      W = Math.floor(innerWidth*DPR);
      H = Math.floor(innerHeight*DPR);
      canvas.width=W; canvas.height=H;
      canvas.style.width=innerWidth+"px";
      canvas.style.height=innerHeight+"px";
    }
    addEventListener("resize", resize);

    // world
    const world = {
      g: 1800, // gravity px/s^2
      wind: 0,
      t:0
    };

    const player = {
      x:0, y:0, vx:0, vy:0,
      hp: 100,
      hue: 200,
      power: 760, // launch speed
      coinsPerShot: 1,
      bob: 0
    };

    const enemy = {
      x:0, y:0,
      hp: 120,
      hue: 340,
      bob: 0,
      aiCd: 0
    };

    const terrain = {
      baseY:0,
      bumps: [] // noise-like control points
    };

    let aiming = false;
    let aim = { sx:0, sy:0, ex:0, ey:0, ang: -0.7, pow: 1.0 };

    let projectiles = [];
    let particles = [];
    let rings = [];
    let shake = 0;
    let flash = 0;

    function rnd(a,b){ return a + Math.random()*(b-a); }
    function clamp(n,a,b){ return Math.max(a, Math.min(b,n)); }

    function initWorld(){
      resize();
      terrain.baseY = H*0.72;
      terrain.bumps = Array.from({length: 18}, (_,i)=>({
        x: (i/17)*W,
        y: terrain.baseY + Math.sin(i*0.7)*rnd(-26,26)*DPR
      }));
      player.x = W*0.22; player.y = groundY(player.x) - 44*DPR;
      enemy.x  = W*0.78; enemy.y  = groundY(enemy.x)  - 46*DPR;
      world.wind = rnd(-260,260);
      world.t=0;
      player.hp=100;
      enemy.hp=120;
      projectiles.length=0; particles.length=0; rings.length=0;
      shake=0; flash=0;
    }

    function groundY(x){
      // simple interp over bumps
      const pts = terrain.bumps;
      for(let i=0;i<pts.length-1;i++){
        if(x >= pts[i].x && x <= pts[i+1].x){
          const t = (x-pts[i].x)/(pts[i+1].x-pts[i].x);
          const y = pts[i].y*(1-t) + pts[i+1].y*t;
          return y;
        }
      }
      return terrain.baseY;
    }

    function drawBackground(dt){
      // gradient sky
      const g = ctx.createRadialGradient(W*0.5,H*0.25,0,W*0.5,H*0.25,Math.max(W,H)*0.75);
      g.addColorStop(0,"rgba(255,215,130,0.10)");
      g.addColorStop(0.35,"rgba(180,120,255,0.08)");
      g.addColorStop(0.7,"rgba(120,200,255,0.07)");
      g.addColorStop(1,"rgba(0,0,0,0)");
      ctx.fillStyle = "#050507";
      ctx.fillRect(0,0,W,H);
      ctx.fillStyle = g;
      ctx.fillRect(0,0,W,H);

      // animated clouds (neon fog)
      const t = world.t;
      for(let i=0;i<6;i++){
        const x = ((t*90*DPR) + i*W*0.22) % (W + 260*DPR) - 130*DPR;
        const y = H*0.18 + Math.sin(t*0.6+i)*H*0.03;
        const r = (220 + i*18)*DPR;
        const cg = ctx.createRadialGradient(x,y,0,x,y,r);
        cg.addColorStop(0, `rgba(180,120,255,${0.06})`);
        cg.addColorStop(1, `rgba(180,120,255,0)`);
        ctx.fillStyle = cg;
        ctx.beginPath(); ctx.arc(x,y,r,0,Math.PI*2); ctx.fill();
      }

      // neon grid ground
      const horizon = H*0.58;
      ctx.globalAlpha = 0.25;
      ctx.lineWidth = 1*DPR;
      for(let i=0;i<30;i++){
        const z = i/30;
        const y = horizon + z*z*(H-horizon);
        ctx.strokeStyle = `rgba(120,200,255,${0.06 + z*0.20})`;
        ctx.beginPath(); ctx.moveTo(0,y); ctx.lineTo(W,y); ctx.stroke();
      }
      for(let i=-18;i<=18;i++){
        const x = W*0.5 + i*W*0.045;
        ctx.strokeStyle = `rgba(180,120,255,0.12)`;
        ctx.beginPath(); ctx.moveTo(x, H); ctx.lineTo(W*0.5 + i*W*0.010, horizon); ctx.stroke();
      }
      ctx.globalAlpha = 1;

      // wind beam sweep
      const sweep = (Math.sin(world.t*0.9)+1)/2;
      const sx = W*(0.15 + sweep*0.7);
      const beam = ctx.createLinearGradient(sx-220*DPR,0,sx+220*DPR,0);
      beam.addColorStop(0,"rgba(255,215,130,0)");
      beam.addColorStop(0.5,"rgba(255,215,130,0.12)");
      beam.addColorStop(1,"rgba(255,215,130,0)");
      ctx.fillStyle = beam;
      ctx.globalAlpha = 0.45;
      ctx.fillRect(0,0,W,H);
      ctx.globalAlpha = 1;
    }

    function drawTerrain(){
      // terrain body
      ctx.beginPath();
      ctx.moveTo(0,H);
      ctx.lineTo(0,groundY(0));
      for(let x=0;x<=W;x+=18*DPR){
        ctx.lineTo(x, groundY(x));
      }
      ctx.lineTo(W,H);
      ctx.closePath();

      const tg = ctx.createLinearGradient(0,terrain.baseY,0,H);
      tg.addColorStop(0,"rgba(255,255,255,0.04)");
      tg.addColorStop(1,"rgba(0,0,0,0.35)");
      ctx.fillStyle = tg;
      ctx.fill();

      // neon edge
      ctx.strokeStyle="rgba(120,200,255,0.22)";
      ctx.lineWidth=2*DPR;
      ctx.beginPath();
      ctx.moveTo(0,groundY(0));
      for(let x=0;x<=W;x+=18*DPR) ctx.lineTo(x, groundY(x));
      ctx.stroke();
    }

    function aura(x,y,hue,alpha,r){
      const g = ctx.createRadialGradient(x,y,0,x,y,r);
      g.addColorStop(0, `hsla(${hue},95%,70%,${alpha})`);
      g.addColorStop(1, `hsla(${hue},95%,70%,0)`);
      ctx.fillStyle=g;
      ctx.beginPath(); ctx.arc(x,y,r,0,Math.PI*2); ctx.fill();
    }

    function drawTank(t, x,y, hue, facing){
      // breathing bob
      const bob = Math.sin(world.t*3 + t)*5*DPR;
      const breath = (Math.sin(world.t*2 + t)+1)/2;

      aura(x, y-20*DPR, hue, 0.20, (90+breath*12)*DPR);

      // shadow
      ctx.globalAlpha=0.35;
      ctx.fillStyle="rgba(0,0,0,0.55)";
      ctx.beginPath(); ctx.ellipse(x, y+34*DPR, 34*DPR, 14*DPR, 0, 0, Math.PI*2); ctx.fill();
      ctx.globalAlpha=1;

      // body
      ctx.fillStyle="rgba(255,255,255,0.10)";
      ctx.strokeStyle=`hsla(${hue},90%,75%,0.70)`;
      ctx.lineWidth=2.2*DPR;

      const w=70*DPR, h=34*DPR;
      roundRect(x-w/2, y-h/2+bob, w, h, 14*DPR); ctx.fill(); ctx.stroke();

      // turret
      ctx.fillStyle="rgba(255,255,255,0.08)";
      ctx.beginPath(); ctx.ellipse(x, y-16*DPR+bob, 22*DPR, 16*DPR, 0,0,Math.PI*2);
      ctx.fill(); ctx.stroke();

      // cannon
      const ang = facing*(0.22 + Math.sin(world.t*1.4+t)*0.06);
      ctx.save();
      ctx.translate(x, y-18*DPR+bob);
      ctx.rotate(ang);
      const lg = ctx.createLinearGradient(0,0,70*DPR,0);
      lg.addColorStop(0, `hsla(${hue},95%,70%,0.0)`);
      lg.addColorStop(0.25, `hsla(${hue},95%,70%,0.75)`);
      lg.addColorStop(1, `hsla(${hue},95%,75%,0.0)`);
      ctx.fillStyle=lg;
      ctx.beginPath(); ctx.roundRect(0, -5*DPR, 70*DPR, 10*DPR, 5*DPR); ctx.fill();
      ctx.restore();

      // core blink
      ctx.fillStyle=`hsla(${hue},95%,70%,${0.35+breath*0.25})`;
      ctx.beginPath(); ctx.arc(x, y-4*DPR+bob, 7*DPR*(1+breath*0.25), 0, Math.PI*2); ctx.fill();
    }

    function roundRect(x,y,w,h,r){
      ctx.beginPath();
      ctx.moveTo(x+r,y);
      ctx.arcTo(x+w,y,x+w,y+h,r);
      ctx.arcTo(x+w,y+h,x,y+h,r);
      ctx.arcTo(x,y+h,x,y,r);
      ctx.arcTo(x,y,x+w,y,r);
      ctx.closePath();
    }

    function spawnExplosion(x,y,hue,scale=1){
      rings.push({x,y,r:20*DPR,a:0.9,w:10*DPR,hue});
      const n = Math.floor(140*scale);
      for(let i=0;i<n;i++){
        particles.push({
          x,y,
          vx:(Math.random()*2-1)*rnd(260,780)*DPR/100,
          vy:(Math.random()*-2-0.4)*rnd(340,980)*DPR/100,
          a:1,
          s:rnd(2.0,5.5)*DPR,
          g:rnd(1200,1800)*DPR/1000,
          hue:hue + rnd(-18,18),
          rot:rnd(0,Math.PI),
          glow:rnd(0.3,1.1)
        });
      }
      shake = Math.min(26*DPR, shake + 12*DPR*scale);
      flash = Math.min(1, flash + 0.9*scale);
    }

    function fire(fromX, fromY, toX, toY, hue, powerMul){
      // calculate angle from drag, clamp
      const dx = (toX - fromX);
      const dy = (toY - fromY);
      let ang = Math.atan2(dy, dx);
      // DDT style: player shoots upward mostly
      ang = clamp(ang, -2.75, -0.15);
      const speed = player.power * powerMul;

      const vx = Math.cos(ang) * speed;
      const vy = Math.sin(ang) * speed;

      projectiles.push({
        x: fromX, y: fromY,
        vx, vy,
        hue,
        life: 6.0,
        trail: []
      });

      // muzzle flash
      spawnExplosion(fromX + Math.cos(ang)*44*DPR, fromY + Math.sin(ang)*44*DPR, hue, 0.55);
    }

    function updateProjectiles(dt){
      for(let i=projectiles.length-1;i>=0;i--){
        const p = projectiles[i];
        p.life -= dt;
        p.vy += world.g * dt;
        p.vx += world.wind * dt;
        p.x += p.vx * dt;
        p.y += p.vy * dt;

        p.trail.push({x:p.x,y:p.y,a:1});
        if(p.trail.length>18) p.trail.shift();

        // hit ground
        const gy = groundY(p.x);
        if(p.y >= gy - 2*DPR){
          spawnExplosion(p.x, gy, p.hue, 1.0);
          // damage enemy if close
          const dist = Math.hypot(enemy.x - p.x, (enemy.y-20*DPR) - gy);
          if(dist < 140*DPR){
            enemy.hp -= Math.floor(26 + rnd(0,18));
            if(enemy.hp <= 0){
              enemy.hp = 120;
              // reward
              walletCoins += 8;
              $("coins").textContent = walletCoins.toLocaleString();
              spawnExplosion(enemy.x, enemy.y-30*DPR, 45, 1.25);
            } else {
              spawnExplosion(enemy.x, enemy.y-30*DPR, enemy.hue, 0.65);
            }
          }
          projectiles.splice(i,1);
          continue;
        }

        // out
        if(p.life<=0 || p.x<-200*DPR || p.x>W+200*DPR || p.y>H+400*DPR){
          projectiles.splice(i,1);
        }
      }
    }

    function updateParticles(dt){
      // rings
      for(let i=rings.length-1;i>=0;i--){
        const r = rings[i];
        r.r += 520*DPR*dt;
        r.a *= 0.90;
        r.w *= 0.96;
        if(r.a<0.04) rings.splice(i,1);
      }

      // particles
      for(let i=particles.length-1;i>=0;i--){
        const p = particles[i];
        p.vy += p.g*dt;
        p.x += p.vx*dt*60;
        p.y += p.vy*dt*60;
        p.a *= 0.975;
        p.rot += 0.18;
        if(p.a<0.05 || p.y>H+240*DPR) particles.splice(i,1);
      }

      if(shake>0){ shake *= 0.86; if(shake<0.2) shake=0; }
      if(flash>0){ flash *= 0.86; if(flash<0.02) flash=0; }
    }

    function drawProjectiles(){
      for(const p of projectiles){
        // trail
        for(let i=0;i<p.trail.length;i++){
          const t = p.trail[i];
          const a = (i/p.trail.length);
          aura(t.x, t.y, p.hue, 0.10*(1-a), 28*DPR*(1-a));
        }

        // bullet core
        aura(p.x,p.y,p.hue,0.25,40*DPR);
        ctx.fillStyle=`hsla(${p.hue},95%,70%,0.95)`;
        ctx.beginPath(); ctx.arc(p.x,p.y,4.6*DPR,0,Math.PI*2); ctx.fill();
      }
    }

    function drawParticles(){
      // rings
      for(const r of rings){
        ctx.strokeStyle = `hsla(${r.hue},95%,70%,${r.a})`;
        ctx.lineWidth = r.w;
        ctx.beginPath(); ctx.arc(r.x,r.y,r.r,0,Math.PI*2); ctx.stroke();
      }

      for(const p of particles){
        ctx.save();
        ctx.translate(p.x,p.y);
        ctx.rotate(p.rot);
        ctx.globalAlpha = p.a;

        ctx.fillStyle = `hsla(${p.hue},95%,70%,${0.25*p.glow})`;
        ctx.beginPath(); ctx.arc(0,0, 10*DPR*p.glow, 0, Math.PI*2); ctx.fill();

        ctx.fillStyle = `hsla(${p.hue},95%,70%,0.95)`;
        ctx.fillRect(-p.s/2,-p.s/2,p.s,p.s*0.62);

        ctx.restore();
      }

      if(flash>0){
        ctx.fillStyle = `rgba(255,255,255,${flash*0.16})`;
        ctx.fillRect(0,0,W,H);
      }
    }

    function drawAim(){
      if(!aiming) return;
      const sx = aim.sx, sy=aim.sy, ex=aim.ex, ey=aim.ey;
      const hue = player.hue;

      // aiming line glow
      ctx.globalAlpha = 0.9;
      ctx.lineWidth = 3*DPR;
      ctx.strokeStyle = `hsla(${hue},95%,70%,0.55)`;
      ctx.beginPath(); ctx.moveTo(sx,sy); ctx.lineTo(ex,ey); ctx.stroke();

      // predicted parabola
      const dx = ex-sx, dy=ey-sy;
      let ang = Math.atan2(dy,dx);
      ang = clamp(ang, -2.75, -0.15);
      const speed = player.power * aim.pow;
      let vx = Math.cos(ang)*speed;
      let vy = Math.sin(ang)*speed;

      let x=sx, y=sy;
      ctx.globalAlpha = 0.85;
      for(let i=0;i<24;i++){
        const t = i*0.08;
        const px = x + vx*t + 0.5*world.wind*t*t;
        const py = y + vy*t + 0.5*world.g*t*t;
        aura(px,py,hue,0.10,18*DPR);
      }
      ctx.globalAlpha = 1;
    }

    function enemyAI(dt){
      enemy.aiCd -= dt;
      if(enemy.aiCd > 0) return;
      enemy.aiCd = rnd(2.0, 3.8);

      // enemy fires back (no coin cost)
      const tx = player.x + rnd(-40,40)*DPR;
      const ty = player.y - 40*DPR;
      fire(enemy.x, enemy.y-30*DPR, tx, ty, enemy.hue, rnd(0.85,1.05));
    }

    function spendCoins(n){
      if(walletCoins < n) return false;
      walletCoins -= n;
      $("coins").textContent = walletCoins.toLocaleString();
      return true;
    }

    function startGame(withLogin){
      $("login").classList.add("hide");
      $("ui").classList.remove("hide");
      initWorld();

      (async ()=>{
        await syncUserUI();
        if(withLogin){
          await refreshWallet();
        } else {
          walletCoins = 50;
          $("coins").textContent = walletCoins.toLocaleString();
          $("acct").textContent = "Demo Player";
        }
      })();

      // input: drag to aim, release to shoot
      const pointer = {down:false, id:null};

      function getPos(e){
        const rect = canvas.getBoundingClientRect();
        const x = (e.clientX - rect.left) * DPR;
        const y = (e.clientY - rect.top) * DPR;
        return {x,y};
      }

      canvas.addEventListener("pointerdown",(e)=>{
        pointer.down=true; pointer.id=e.pointerId;
        const p = getPos(e);
        aiming=true;
        aim.sx = player.x;
        aim.sy = player.y - 30*DPR;
        aim.ex = p.x;
        aim.ey = p.y;
        aim.pow = 1.0;
        canvas.setPointerCapture(e.pointerId);
      }, {passive:true});

      canvas.addEventListener("pointermove",(e)=>{
        if(!pointer.down) return;
        const p = getPos(e);
        aim.ex = p.x;
        aim.ey = p.y;
        // power by drag distance
        const d = Math.hypot(aim.ex-aim.sx, aim.ey-aim.sy);
        aim.pow = clamp(d/(420*DPR), 0.35, 1.35);
      }, {passive:true});

      canvas.addEventListener("pointerup",(e)=>{
        if(!pointer.down) return;
        pointer.down=false;

        // spend 1 coin per shot in real mode; demo also spends
        if(!spendCoins(player.coinsPerShot)){
          // shake feedback
          shake = Math.min(18*DPR, shake + 10*DPR);
          return;
        }
        fire(player.x, player.y-30*DPR, aim.ex, aim.ey, player.hue, aim.pow);
        aiming=false;
      }, {passive:true});

      // game loop
      let last = performance.now();
      function loop(now){
        const dt = Math.min(0.05, (now-last)/1000);
        last = now;
        world.t += dt;

        // wind slowly changes
        world.wind += Math.sin(world.t*0.18)*dt*18;
        world.wind = clamp(world.wind, -420, 420);

        updateProjectiles(dt);
        updateParticles(dt);
        enemyAI(dt);

        // render (with shake)
        ctx.save();
        let sx=0, sy=0;
        if(shake>0){
          sx = (Math.random()*2-1)*shake;
          sy = (Math.random()*2-1)*shake;
        }
        ctx.setTransform(1,0,0,1,sx,sy);

        drawBackground(dt);
        drawTerrain();

        drawTank(0, player.x, player.y, player.hue, +1);
        drawTank(2, enemy.x, enemy.y, enemy.hue, -1);

        drawProjectiles();
        drawParticles();
        drawAim();

        ctx.restore();
        requestAnimationFrame(loop);
      }
      requestAnimationFrame(loop);
    }

    // Auto start if already logged in
    (async ()=>{
      const { data } = await supabase.auth.getUser();
      if(data?.user){
        startGame(true);
      }
    })();
  </script>
</body>
</html>
